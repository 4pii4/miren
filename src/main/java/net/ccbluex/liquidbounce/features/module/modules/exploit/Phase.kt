/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.Block
import net.minecraft.block.BlockAir
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.MathHelper
import java.util.*
import kotlin.math.cos
import kotlin.math.sin

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
class Phase : Module() {
    val modeValue = ListValue(
        "Mode", arrayOf(
            "Vanilla",
            "Skip",
            "Spartan",
            "Clip",
            "AAC3.5.0",
            "AACv4",
            "Mineplex",
            "Redesky",
            "SmartVClip"
        ), "Vanilla"
    )
    private val tickTimer = TickTimer()
    private var mineplexClip = false
    private var noRot = false
    private val mineplexTickTimer = TickTimer()
    private var stage = 0
    override fun onEnable() {
        stage = 0
        if (modeValue.get().equals("aacv4", ignoreCase = true)) mc.timer.timerSpeed = 0.1f
    }

    override fun onDisable() {
        if (modeValue.get().equals("aacv4", ignoreCase = true)) mc.timer.timerSpeed = 1f
    }

    private fun doPhase() {
        val netHandlerPlayClient = mc.netHandler
        val isInsideBlock = collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !is BlockAir }
        when (modeValue.get().lowercase(Locale.getDefault())) {
            "vanilla" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.2, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                tickTimer.reset()
            }

            "skip" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val direction = MovementUtils.direction
                val posX = -sin(direction) * 0.3
                val posZ = cos(direction) * 0.3
                var i = 0
                while (i < 3) {
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.06, mc.thePlayer.posZ, true))
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + posX * i, mc.thePlayer.posY, mc.thePlayer.posZ + posZ * i, true))
                    ++i
                }
                mc.thePlayer.entityBoundingBox = mc.thePlayer.entityBoundingBox.offset(posX, 0.0, posZ)
                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX + posX, mc.thePlayer.posY, mc.thePlayer.posZ + posZ)
                tickTimer.reset()
            }

            "spartan" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.2, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                tickTimer.reset()
            }

            "clip" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX = mc.thePlayer.posX
                val oldZ = mc.thePlayer.posZ
                var i = 1
                while (i <= 10) {
                    val x = -sin(yaw) * i
                    val z = cos(yaw) * i
                    if (getBlock(BlockPos(oldX + x, mc.thePlayer.posY, oldZ + z)) is BlockAir && getBlock(BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)) is BlockAir) {
                        mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                        break
                    }
                    i++
                }
                tickTimer.reset()
            }

            "aac3.5.0" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX = mc.thePlayer.posX
                val oldZ = mc.thePlayer.posZ
                val x = -sin(yaw)
                val z = cos(yaw)
                mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                tickTimer.reset()
            }

            "smartvclip" -> {
                val cageCollision = (mc.theWorld.getBlockState(BlockPos(mc.thePlayer).up(3)).block !== Blocks.air
                        && mc.theWorld.getBlockState(BlockPos(mc.thePlayer).down()).block !== Blocks.air)
                noRot = mc.thePlayer.ticksExisted >= 0 && mc.thePlayer.ticksExisted <= 40 && cageCollision
                if (mc.thePlayer.ticksExisted >= 20 && mc.thePlayer.ticksExisted < 40 && cageCollision) {
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ, false))
                    mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ)
                }
            }

            "redesky" -> {
                state = false
            }

            "redesky2" -> {
                state = false
            }
        }
    }
    @EventTarget
    fun onUpdate(event: UpdateEvent?) {
        if (modeValue.get().equals("aacv4", ignoreCase = true)) {
            when (stage) {
                1 -> {
                    mc.thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY + -0.00000001, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                    mc.thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                }

                3 -> {
                    state = false
                }
            }
            stage++
            return
        } else if (modeValue.get().equals("redesky", ignoreCase = true)) {
            when (stage) {
                0 -> {
                    mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.00000001, mc.thePlayer.posZ)
                    mc.thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY - 0.00000001, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                }

                1 -> {
                    mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ)
                    mc.thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                }

                3 -> {
                    state = false
                }
            }
            stage++
            return
        }
        val isInsideBlock = collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !is BlockAir }
        if (isInsideBlock && !modeValue.get().equals("Mineplex", ignoreCase = true) && !modeValue.get().equals("SmartVClip", ignoreCase = true)) {
            mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
        }
        doPhase()
        tickTimer.update()
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mc.thePlayer != null && collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !is BlockAir } && event.boundingBox != null && event.boundingBox!!.maxY > mc.thePlayer.entityBoundingBox.minY && !modeValue.get().equals("Mineplex", ignoreCase = true) && !modeValue.get().equals("SmartVClip", ignoreCase = true)) {
            val axisAlignedBB = event.boundingBox
            event.boundingBox = AxisAlignedBB(axisAlignedBB!!.maxX, mc.thePlayer.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is C03PacketPlayer) {
            if (modeValue.get().equals("AAC3.5.0", ignoreCase = true)) {
                val yaw = MovementUtils.direction.toFloat()
                packet.x -= MathHelper.sin(yaw) * 0.00000001
                packet.z += MathHelper.cos(yaw) * 0.00000001
            }
            if (modeValue.get().equals("SmartVClip", ignoreCase = true) && noRot && packet.rotating) event.cancelEvent()
        }
        if (packet is C0BPacketEntityAction && modeValue.get().equals("SmartVClip", ignoreCase = true) && noRot) event.cancelEvent()
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        if (modeValue.get().equals("mineplex", ignoreCase = true)) {
            if (mc.thePlayer.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return
            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset()
                mineplexClip = false
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val direction = MovementUtils.direction
                mc.thePlayer.setPosition(mc.thePlayer.posX + -sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + cos(direction) * offset)
            }
        }
        if (modeValue.get().equals("SmartVClip", ignoreCase = true) && noRot) event.zeroXZ()
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    @EventTarget
    fun onJump(event: JumpEvent) {
        if (modeValue.get().equals("SmartVClip", ignoreCase = true) && noRot) event.cancelEvent()
    }

    override val tag: String
        get() = modeValue.get()
}
